# Work in Progress: Athena Decision Service Integration

**Date**: 2025-11-03
**Status**: Implementation complete, awaiting area registration infrastructure
**Branch**: main (local only, NOT committed)

## What Was Implemented

### 1. Files Modified

#### src/athena_api/client.py
- Added `record_decisions(decisions: list[DecisionRecord])` method for bulk decision submission
- Updated `_request()` method to handle both single Pydantic models and lists of models
- Supports both POST /api/v1/Decision (single) and POST /api/v1/Decisions (bulk)

#### src/smartem_backend/consumer.py
- Added imports:
  ```python
  from athena_api.client import AthenaClient
  from athena_api.model.request import DecisionRecord, DecisionType, PluginType
  ```

- Added Athena client initialization (line ~94-101):
  ```python
  athena_client: AthenaClient | None = None
  athena_url = conf.get("athena_url")
  if athena_url:
      athena_client = AthenaClient(base_url=athena_url, logger=logger)
  ```

- Added helper functions (line ~104-180):
  - `send_decision_to_athena()` - for single decisions
  - `send_decisions_to_athena()` - for bulk decisions (uses POST /api/v1/Decisions)

- Updated event handlers with TODO comments and commented-out Athena calls:
  - `handle_gridsquare_model_prediction()` (line ~797-853)
  - `handle_foilhole_model_prediction()` (line ~856-916)
  - `handle_multi_foilhole_model_prediction()` (line ~919-994)

### 2. Design Decisions

#### Decision Type Mapping
- Grid square predictions → `DecisionType.GRID_SQUARE_SELECTION`
- Foil hole predictions → `DecisionType.FOIL_HOLE_SELECTION`
- Decision value: "true" if prediction > 0.5, else "false"
- Details field: includes prediction value and model name

#### Bulk vs Single Requests
- **Single foilhole**: Use POST /api/v1/Decision
- **Multiple foilholes**: Use POST /api/v1/Decisions (bulk endpoint)
- Reason: Prevents microscope blocking - if we send foilhole decisions sequentially, microscope will process first one and block subsequent ones until done

#### Plugin Type
- All decisions use `PluginType.CUSTOM`
- Decided by: "smartem_ml_model"

### 3. What's Missing (Blockers)

The code is **complete but commented out** until these are implemented:

#### A. Database Schema Changes Needed
```sql
-- Add to gridsquare table
ALTER TABLE gridsquare ADD COLUMN athena_area_id INTEGER;

-- Add to foilhole table
ALTER TABLE foilhole ADD COLUMN athena_area_id INTEGER;

-- Add to grid or acquisition table (for session mapping)
ALTER TABLE grid ADD COLUMN athena_session_id UUID;
```

#### B. Area Registration Flow Needed
When gridsquares/foilholes are created, need to:
1. Register area with Athena API: `POST /api/v1/Area`
   ```python
   area = Area(
       id=athena_area_id,  # Integer ID from Athena
       sessionId=athena_session_id,
       areaType=AreaType.GRIDSQUARE,  # or AreaType.FOILHOLE
       parentId=parent_athena_area_id  # optional
   )
   athena_client.register_area(area)
   ```
2. Store returned `athena_area_id` in database
3. Use this `athena_area_id` when posting decisions

#### C. Session Management Needed
- When Grid/Acquisition starts, register session with Athena: `POST /api/v1/Session`
- Store `athena_session_id` (UUID) in database
- Retrieve this session_id when posting decisions

### 4. How to Complete This Work

#### Step 1: Database Migration
Create Alembic migration:
```bash
POSTGRES_HOST=localhost POSTGRES_PORT=30432 POSTGRES_DB=smartem_db \
POSTGRES_USER=username POSTGRES_PASSWORD=password \
alembic revision --autogenerate -m "add athena area and session ids"
```

Edit migration to add:
- `gridsquare.athena_area_id` (Integer, nullable)
- `foilhole.athena_area_id` (Integer, nullable)
- `grid.athena_session_id` (UUID, nullable) or similar

Run migration:
```bash
POSTGRES_HOST=localhost POSTGRES_PORT=30432 POSTGRES_DB=smartem_db \
POSTGRES_USER=username POSTGRES_PASSWORD=password \
alembic upgrade head
```

#### Step 2: Update Database Models
In `src/smartem_backend/model/database.py`:
```python
class GridSquare(SQLModel, table=True):
    # ... existing fields ...
    athena_area_id: int | None = Field(default=None)

class FoilHole(SQLModel, table=True):
    # ... existing fields ...
    athena_area_id: int | None = Field(default=None)

class Grid(SQLModel, table=True):
    # ... existing fields ...
    athena_session_id: str | None = Field(default=None)  # UUID as string
```

#### Step 3: Implement Area Registration
In event handlers that create gridsquares/foilholes (likely in consumer.py or api_server.py):

```python
def handle_gridsquare_created(event_data: dict[str, Any]) -> None:
    # ... existing creation logic ...

    if athena_client:
        # Register area with Athena
        area = Area(
            id=generate_athena_area_id(),  # Need to implement ID generation
            sessionId=get_athena_session_id(grid.uuid),  # Retrieve from grid
            areaType=AreaType.GRIDSQUARE,
            parentId=None  # or parent grid's athena_area_id
        )
        try:
            athena_client.register_area(area)
            # Store athena_area_id in database
            gridsquare.athena_area_id = area.id
            session.commit()
        except Exception as e:
            logger.error(f"Failed to register area with Athena: {e}")
```

#### Step 4: Implement Session Registration
When Grid/Acquisition is created:
```python
def handle_grid_created(event_data: dict[str, Any]) -> None:
    # ... existing creation logic ...

    if athena_client:
        session_record = Session(
            sessionId=uuid.uuid4(),
            sessionName=f"Grid_{grid.name}",
            timestamp=datetime.now(),
            gridType=GridType.HOLEY_CARBON  # or appropriate type
        )
        try:
            athena_client.register_session(session_record)
            grid.athena_session_id = str(session_record.sessionId)
            db_session.commit()
        except Exception as e:
            logger.error(f"Failed to register session with Athena: {e}")
```

#### Step 5: Uncomment Decision Submission Code
In `src/smartem_backend/consumer.py`:

1. **handle_gridsquare_model_prediction()** (line ~842-848):
   - Uncomment the `send_decision_to_athena()` call
   - Add retrieval: `athena_session_id = get_session_id_from_grid(gridsquare.grid_uuid)`

2. **handle_foilhole_model_prediction()** (line ~905-911):
   - Uncomment the `send_decision_to_athena()` call
   - Add retrieval: `athena_session_id = get_session_id_from_foilhole(foilhole.uuid)`

3. **handle_multi_foilhole_model_prediction()** (line ~979-989):
   - Uncomment the `send_decisions_to_athena()` call
   - Fetch foilholes with athena_area_ids
   - Build decisions_data list

#### Step 6: Configuration
Add to config (e.g., .env or config.yaml):
```
ATHENA_URL=http://athena-service:8000
```

#### Step 7: Testing
1. Start Athena mock server:
   ```python
   from athena_api.mock.server import AthenaAPIServer
   server = AthenaAPIServer()
   server.run(port=8000)
   ```

2. Publish test predictions:
   ```bash
   python tools/external_message_simulator.py gridsquare-prediction --count 1
   python tools/external_message_simulator.py foilhole-prediction --count 3
   ```

3. Verify decisions are posted to Athena

### 5. Key Files to Review Later

When resuming this work, review:
- `src/athena_api/client.py` - lines 80-118 (_request method changes), 316-318 (record_decisions)
- `src/smartem_backend/consumer.py` - lines 21-22 (imports), 94-180 (helpers), 797-994 (handlers)
- `docs/athena-decision-service-api-spec.json` - Decision and Decisions endpoints
- `src/athena_api/model/request.py` - DecisionRecord, DecisionType, PluginType, Area, Session schemas

### 6. Testing Commands

```bash
# Run consumer with Athena URL configured
export ATHENA_URL=http://localhost:8000
python -m smartem_backend.consumer

# Simulate predictions
python tools/external_message_simulator.py gridsquare-prediction --gridsquare-id GS_001 --prediction-score 0.85
python tools/external_message_simulator.py foilhole-prediction --gridsquare-id GS_001 --foilhole-count 5

# Check Athena decisions (if mock server running)
curl http://localhost:8000/api/v1/Session/{session_id}/Decisions
```

### 7. Pre-commit Status
- All files pass ruff linting and formatting
- Import sorting fixed
- Code follows project style guide

### 8. Notes
- NO commits made to git
- NO pushes to remote
- All changes are local only
- This markdown file serves as the resumption point
- Files are formatted and ready for commit when area registration is complete
